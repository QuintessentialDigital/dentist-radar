import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';
const __filename=fileURLToPath(import.meta.url);const __dirname=path.dirname(__filename);
const dbPath=path.join(__dirname,'..','data.sqlite');let db;
export function ensureDb(){db=new Database(dbPath);db.pragma('journal_mode = WAL');db.exec(`CREATE TABLE IF NOT EXISTS users(id INTEGER PRIMARY KEY AUTOINCREMENT,email TEXT UNIQUE,plan TEXT NOT NULL DEFAULT 'free',quick_until TEXT,welcomed INTEGER NOT NULL DEFAULT 0,created_at TEXT NOT NULL DEFAULT (datetime('now')));CREATE TABLE IF NOT EXISTS watches(id INTEGER PRIMARY KEY AUTOINCREMENT,user_id INTEGER,postcode TEXT NOT NULL,radius_miles INTEGER NOT NULL,frequency_minutes INTEGER NOT NULL DEFAULT 60,contact_email TEXT NOT NULL,active INTEGER NOT NULL DEFAULT 1,last_run_at TEXT,created_at TEXT NOT NULL DEFAULT (datetime('now')));CREATE TABLE IF NOT EXISTS practices(id INTEGER PRIMARY KEY AUTOINCREMENT,nhs_url TEXT NOT NULL UNIQUE,name TEXT);CREATE TABLE IF NOT EXISTS practice_status(id INTEGER PRIMARY KEY AUTOINCREMENT,practice_id INTEGER NOT NULL,status_text TEXT,accepting_flag INTEGER NOT NULL DEFAULT 0,checked_at TEXT NOT NULL DEFAULT (datetime('now')));`);} 
export function getDb(){return db;} export function upsertUser(email){db.prepare(`INSERT INTO users (email) VALUES (?) ON CONFLICT(email) DO NOTHING`).run(email);return db.prepare(`SELECT * FROM users WHERE email=?`).get(email);} export function setPlan(email,plan){db.prepare(`UPDATE users SET plan=? WHERE email=?`).run(plan,email);return db.prepare(`SELECT * FROM users WHERE email=?`).get(email);} export function setQuickUntil(email,untilIso){db.prepare(`UPDATE users SET quick_until=? WHERE email=?`).run(untilIso,email);} export function setWelcomed(email){db.prepare(`UPDATE users SET welcomed=1 WHERE email=?`).run(email);} export function getUserByEmail(email){return db.prepare(`SELECT * FROM users WHERE email=?`).get(email);} export function createWatch({user_id,postcode,radius_miles,frequency_minutes,contact_email}){const info=db.prepare(`INSERT INTO watches (user_id, postcode, radius_miles, frequency_minutes, contact_email) VALUES (?,?,?,?,?)`).run(user_id,postcode,radius_miles,frequency_minutes,contact_email);return db.prepare(`SELECT * FROM watches WHERE id=?`).get(info.lastInsertRowid);} export function listWatchesPublic(){return db.prepare(`SELECT id, postcode, radius_miles, frequency_minutes, active, last_run_at, created_at FROM watches ORDER BY id DESC`).all();} export function listWatchesAdmin(){return db.prepare(`SELECT * FROM watches ORDER BY id DESC`).all();} export function getPracticeByUrl(url){return db.prepare(`SELECT * FROM practices WHERE nhs_url=?`).get(url);} export function savePractice(url,name){db.prepare(`INSERT INTO practices (nhs_url, name) VALUES (?,?) ON CONFLICT(nhs_url) DO UPDATE SET name=excluded.name`).run(url,name);return getPracticeByUrl(url);} export function insertStatus(practice_id,status_text,accepting_flag){db.prepare(`INSERT INTO practice_status (practice_id, status_text, accepting_flag) VALUES (?,?,?)`).run(practice_id,status_text,accepting_flag);} export function touchWatch(id){db.prepare(`UPDATE watches SET last_run_at = datetime('now') WHERE id=?`).run(id);}